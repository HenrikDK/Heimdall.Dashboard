<template id="cluster">
    <div class="pl-2 pr-4 w-100">

        <div class="flex my-2 items-center">
            <span class="text-gray-500 dark:text-gray-300 text-2xl font-light sans">Cluster</span>
        </div>

        <br/>
        
        <div class="flex justify-between mb-4 mt-1">
            <div class="wide-graph">
                <v-chart :option="charts.cluster.performance" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="large-graph">
                <v-chart :option="charts.cluster.cpus" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="large-graph">
                <v-chart :option="charts.cluster.memory" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
        </div>
        
        <div class="flex my-2 items-center">
            <span class="text-gray-500 dark:text-gray-300 text-2xl font-light sans">Workloads</span>
        </div>
        
        <br/>
        
        <div class="flex justify-between mb-4 mt-1">
            <div class="graph">
                <v-chart :option="charts.workloads.pods" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.deployments" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.daemonsets" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.statefullsets" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.replicasets" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.jobs" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.cronjobs" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
        </div>
    </div>
</template>

<script type="module">
    import {useDark} from "vueuse";
    const isDark = useDark();
    
    components["cluster"] = {
        template: "#cluster",
        data() {
            return {
                initOptions: { renderer: "svg" },
                cluster:{
                    pods: null,
                    deployments: null,
                    daemonSets: null,
                    statefulSets: null,
                    replicaSets: null,
                    jobs: null,
                    cronJobs: null,
                },
                metrics:{
                    kubeMemory: null,
                    containerMemory: null,
                    nodeMemory: null,
                    kubeCpu: null,
                    nodeCpu: null,
                },
                isDark: isDark,
                charts:{
                    cluster:{
                        performance: historic(),
                        cpus: current('CPU'),
                        memory: current('Memory')
                    },
                    workloads:{
                        pods: workload('Pods', 0, 0),
                        deployments: workload('Deployments', 0, 0),
                        daemonsets: workload('Daemon Sets', 0, 0),
                        statefullsets: workload('Stateful Sets', 0, 0),
                        replicasets: workload('Replica Sets', 0, 0),
                        jobs: workload('Jobs', 0, 0),
                        cronjobs: workload('Cron Jobs', 0, 0),
                    }
                }
            }
        },
        methods: {
          filterNamespace(values){
            let filtered = values;
            if (this.$props.namespaces.length > 0){
                filtered = values?.filter(x => this.$props.namespaces.some(y => x.metadata.namespace === y));
            }
            return filtered;
          },
          async updateClusterPods() {
              let filtered = this.filterNamespace(this.cluster.pods);
              let running = filtered?.filter(x => (x.status?.phase === "Running" && x.status?.containerStatuses.every(y => y.state.running)) 
                  || x.status?.phase === "Succeeded").length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.pods = workload('Pods', running, pending);
          },
          async updateClusterDeployments() {
              let filtered = this.filterNamespace(this.cluster.deployments);
              let running = filtered?.filter(x => x.status?.replicas === x.status?.readyReplicas).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.deployments = workload('Deployments', running, pending);
          },
          async updateClusterJobs() {
              let filtered = this.filterNamespace(this.cluster.jobs);
              let running = filtered?.filter(x => x.status?.succeeded).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.jobs = workload('Jobs', running, pending);                
          },
          async updateClusterCronJobs() {
              let filtered = this.filterNamespace(this.cluster.cronJobs);
              let running = filtered?.filter(x => x.status?.lastSuccessfulTime).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.cronjobs = workload('Cron Jobs', running, pending);
          },
          async updateClusterStatefulSets() {
              let filtered = this.filterNamespace(this.cluster.statefulSets);
              let running = filtered?.filter(x => x.status?.replicas === x.status?.readyReplicas).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.statefullsets = workload('Stateful Sets', running, pending);
          },
          async updateClusterReplicaSets() {
              let filtered = this.filterNamespace(this.cluster.replicaSets);
              let running = filtered?.filter(x => x.status?.replicas === x.status?.readyReplicas).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.replicasets = workload('Replica Sets', running, pending);
          },
          async updateClusterDaemonSets() {
              let filtered = this.filterNamespace(this.cluster.daemonSets);
              let running = filtered?.filter(x => x.status?.currentNumberScheduled === x.status?.numberReady).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.daemonsets = workload('Daemon Sets', running, pending);
          },
          async updateHistory() {
              
          },
          async updateCpu() {
              let capacity = getMetricLastPoints(this.metrics.kubeCpu, 'kube_node_status_capacity');
              let requestValue = getMetricLastPoints(this.metrics.kubeCpu, 'kube_pod_container_resource_requests');
              let requestPct = requestValue / capacity * 100;
              let requests = {pct: requestPct.toFixed(2), units: requestValue.toFixed(2) };
              
              let limitValue = getMetricLastPoints(this.metrics.kubeCpu, 'kube_pod_container_resource_limits');
              let limitPct = limitValue / capacity * 100;
              if (limitPct > 100){
                  limitPct = 100;
              }
              let limits = {pct: limitPct.toFixed(2), units: limitValue.toFixed(2) };
              
              let usageValue = getMetricLastPoints(this.metrics.nodeCpu);
              let usagePct = usageValue / capacity * 100;
              let usage = {pct: usagePct.toFixed(2), units: usageValue.toFixed(2) };
              
              this.charts.cluster.cpus = current('CPU', 'vCores', usage, requests, limits);
          },
          async updateMemory() {
              let capacity = getMetricLastPoints(this.metrics.kubeMemory, 'kube_node_status_capacity');
              let requestValue = getMetricLastPoints(this.metrics.kubeMemory, 'kube_pod_container_resource_requests');
              let requestPct = requestValue / capacity * 100;
              let requests = {pct: requestPct.toFixed(2), units: (requestValue / 1024 / 1024 / 1024).toFixed(2) };
              
              let limitValue = getMetricLastPoints(this.metrics.kubeMemory, 'kube_pod_container_resource_limits');
              let limitPct = limitValue / capacity * 100;
              if (limitPct > 100){
                  limitPct = 100;
              }
              let limits = {pct: limitPct.toFixed(2), units: (limitValue / 1024 / 1024 / 1024).toFixed(2) };              
              
              let memTotal = getMetricLastPoints(this.metrics.nodeMemory, 'node_memory_MemTotal_bytes');
              let memBuffers = getMetricLastPoints(this.metrics.nodeMemory, 'node_memory_Buffers_bytes');
              let memCache = getMetricLastPoints(this.metrics.nodeMemory, 'node_memory_Cached_bytes');
              let memFree = getMetricLastPoints(this.metrics.nodeMemory, 'node_memory_MemFree_bytes');
              
              let usageValue = memTotal - (memBuffers + memCache + memFree);
              let usagePct = usageValue / capacity * 100;
              let usage = {pct: usagePct.toFixed(2), units: (usageValue / 1024 / 1024 / 1024).toFixed(2) };
              this.charts.cluster.memory = current('Memory', 'GiB', usage, requests, limits);
          },
        },
        watch: {
            'cluster.pods': function () { this.updateClusterPods(); },
            'cluster.deployments': function () { this.updateClusterDeployments(); },
            'cluster.jobs':function () { this.updateClusterJobs(); },
            'cluster.cronJobs':function () { this.updateClusterCronJobs(); },
            'cluster.statefulSets': function () { this.updateClusterStatefulSets(); },
            'cluster.replicaSets': function () { this.updateClusterReplicaSets(); },
            'cluster.daemonSets': function () { this.updateClusterDaemonSets(); },
            'metrics.nodeCpu': function () {this.updateCpu(); },
            'metrics.kubeCpu': function () {this.updateCpu(); },
            'metrics.kubeMemory': function () {this.updateMemory(); },
            'metrics.nodeMemory': function () {this.updateMemory(); },
            namespaces() {
                this.updateClusterPods();
                this.updateClusterDeployments();
                this.updateClusterJobs();
                this.updateClusterCronJobs();
                this.updateClusterStatefulSets();
                this.updateClusterReplicaSets();
                this.updateClusterDaemonSets();
            },            
            nodes(){
              if (this.nodes.length > 0)
              {
                  var host = window.location.origin;
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'kube-memory-stats', { nodes: this.nodes }), j => this.metrics.kubeMemory = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'container-memory', { nodes: this.nodes }), j => this.metrics.containerMemory = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'node-memory-stats', { nodes: this.nodes }), j => this.metrics.nodeMemory = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'kube-cpu-stats', { nodes: this.nodes }), j => this.metrics.kubeCpu = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'node-cpu-stats', { nodes: this.nodes }), j => this.metrics.nodeCpu = j.data.result);
              }
            }
        },
        props: ['namespaces', 'nodes'],
        async mounted() {
          var host = window.location.origin;
          
          streamResults(host + '/k8s/api/v1/pods', j => this.cluster.pods = j);
          streamResults(host + '/k8s/apis/apps/v1/deployments', j => this.cluster.deployments = j)
          streamResults(host + '/k8s/apis/apps/v1/daemonsets', j => this.cluster.daemonSets = j)
          streamResults(host + '/k8s/apis/apps/v1/statefulsets', j => this.cluster.statefulSets = j)
          streamResults(host + '/k8s/apis/apps/v1/replicasets', j => this.cluster.replicaSets = j)
          streamResults(host + '/k8s/apis/batch/v1/cronjobs', j => this.cluster.cronJobs = j)
          streamResults(host + '/k8s/apis/batch/v1/jobs', j => this.cluster.jobs = j)          
        }
    };
        
    routes.push({path:'/', name:'cluster',  component: components["cluster"]})
</script>
