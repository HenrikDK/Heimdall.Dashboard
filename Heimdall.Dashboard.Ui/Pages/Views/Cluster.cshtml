<template id="cluster">
    <div class="pl-2 pr-4 w-100">

        <div class="flex my-2 items-center">
            <span class="text-gray-500 dark:text-gray-300 text-2xl font-light sans">Cluster</span>
        </div>

        <br/>
        
        <div class="flex justify-between mb-4 mt-1">
            <div class="wide-graph">
                <v-chart :option="charts.cluster.performance" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="large-graph">
                <v-chart :option="charts.cluster.cpus" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="large-graph">
                <v-chart :option="charts.cluster.memory" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
        </div>
        
        <div class="flex my-2 items-center">
            <span class="text-gray-500 dark:text-gray-300 text-2xl font-light sans">Workloads</span>
        </div>
        
        <br/>
        
        <div class="flex justify-between mb-4 mt-1">
            <div class="graph">
                <v-chart :option="charts.workloads.pods" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.deployments" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.daemonsets" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.statefullsets" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.replicasets" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.jobs" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
            <div class="graph">
                <v-chart :option="charts.workloads.cronjobs" :theme="isDark ? 'dark' : ''" :init-options="initOptions"></v-chart>
            </div>
        </div>
    </div>
</template>

<script type="module">
    import {useDark} from "vueuse";
    const isDark = useDark();
    
    components["cluster"] = {
        template: "#cluster",
        data() {
            return {
                initOptions: { renderer: "svg" },
                cluster:{
                    pods: null,
                    deployments: null,
                    daemonSets: null,
                    statefulSets: null,
                    replicaSets: null,
                    jobs: null,
                    cronJobs: null,
                },
                metrics:{
                    kubeMemory: null,
                    containerMemory: null,
                    nodeMemory: null,
                    kubeCpu: null,
                    nodeCpu: null,
                },
                isDark: isDark,
                charts:{
                    cluster:{
                        performance: historic(),
                        cpus: current('CPU'),
                        memory: current('Memory')
                    },
                    workloads:{
                        pods: workload('Pods', 0, 0),
                        deployments: workload('Deployments', 0, 0),
                        daemonsets: workload('Daemon Sets', 0, 0),
                        statefullsets: workload('Stateful Sets', 0, 0),
                        replicasets: workload('Replica Sets', 0, 0),
                        jobs: workload('Jobs', 0, 0),
                        cronjobs: workload('Cron Jobs', 0, 0),
                    }
                }
            }
        },
        methods: {
          filterNamespace(values){
            let filtered = values;
            if (this.$props.namespaces.length > 0){
                filtered = values?.filter(x => this.$props.namespaces.some(y => x.metadata.namespace === y));
            }
            return filtered;
          },
          async updateClusterPods() {
              let filtered = this.filterNamespace(this.cluster.pods);
              let running = filtered?.filter(x => (x.status?.phase === "Running" && x.status?.containerStatuses.every(y => y.state.running)) 
                  || x.status?.phase === "Succeeded").length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.pods = workload('Pods', running, pending);
          },
          async updateClusterDeployments() {
              let filtered = this.filterNamespace(this.cluster.deployments);
              let running = filtered?.filter(x => x.status?.replicas === x.status?.readyReplicas).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.deployments = workload('Deployments', running, pending);
          },
          async updateClusterJobs() {
              let filtered = this.filterNamespace(this.cluster.jobs);
              let running = filtered?.filter(x => x.status?.succeeded).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.jobs = workload('Jobs', running, pending);                
          },
          async updateClusterCronJobs() {
              let filtered = this.filterNamespace(this.cluster.cronJobs);
              let running = filtered?.filter(x => x.status?.lastSuccessfulTime).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.cronjobs = workload('Cron Jobs', running, pending);
          },
          async updateClusterStatefulSets() {
              let filtered = this.filterNamespace(this.cluster.statefulSets);
              let running = filtered?.filter(x => x.status?.replicas === x.status?.readyReplicas).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.statefullsets = workload('Stateful Sets', running, pending);
          },
          async updateClusterReplicaSets() {
              let filtered = this.filterNamespace(this.cluster.replicaSets);
              let running = filtered?.filter(x => x.status?.replicas === x.status?.readyReplicas).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.replicasets = workload('Replica Sets', running, pending);
          },
          async updateClusterDaemonSets() {
              let filtered = this.filterNamespace(this.cluster.daemonSets);
              let running = filtered?.filter(x => x.status?.currentNumberScheduled === x.status?.numberReady).length ?? 0;
              let pending = (filtered?.length ?? 0) - running;
              this.charts.workloads.daemonsets = workload('Daemon Sets', running, pending);
          },
          async updateHistory() {
              
          },
          async updateCpu() {
              
          },
          async updateMemory() {
              
          },
        },
        
        watch: {
            namespaces() {
                this.updateClusterPods();
                this.updateClusterDeployments();
                this.updateClusterJobs();
                this.updateClusterCronJobs();
                this.updateClusterStatefulSets();
                this.updateClusterReplicaSets();
                this.updateClusterDaemonSets();
            },            
            'cluster.pods':function () {
                this.updateClusterPods();
            },
            'cluster.deployments': function () {
                this.updateClusterDeployments();
            },
            'cluster.jobs':function () {
                this.updateClusterJobs();            
            },
            'cluster.cronJobs':function () {
                this.updateClusterCronJobs();
            },
            'cluster.statefulSets': function () {
                this.updateClusterStatefulSets();
            },
            'cluster.replicaSets': function () {
                this.updateClusterReplicaSets();
            },
            'cluster.daemonSets': function () {
                this.updateClusterDaemonSets();
            },
            nodes(){
              if (this.nodes.length > 0)
              {
                  var host = window.location.origin;
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'kube-memory-stats', { nodes: this.nodes }), j => this.metrics.kubeMemory = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'container-memory', { nodes: this.nodes }), j => this.metrics.containerMemory = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'node-memory-stats', { nodes: this.nodes }), j => this.metrics.nodeMemory = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'kube-cpu-stats', { nodes: this.nodes }), j => this.metrics.kubeCpu = j.data.result);
                  streamMetrics(host + '/prometheus/api/v1' + getMetric('cluster', 'node-cpu-stats', { nodes: this.nodes }), j => this.metrics.nodeCpu = j.data.result);
              }
            }
        },
        props: ['namespaces', 'nodes'],
        async mounted() {
          var host = window.location.origin;
          
          streamResults(host + '/k8s/api/v1/pods', j => this.cluster.pods = j);
          streamResults(host + '/k8s/apis/apps/v1/deployments', j => this.cluster.deployments = j)
          streamResults(host + '/k8s/apis/apps/v1/daemonsets', j => this.cluster.daemonSets = j)
          streamResults(host + '/k8s/apis/apps/v1/statefulsets', j => this.cluster.statefulSets = j)
          streamResults(host + '/k8s/apis/apps/v1/replicasets', j => this.cluster.replicaSets = j)
          streamResults(host + '/k8s/apis/batch/v1/cronjobs', j => this.cluster.cronJobs = j)
          streamResults(host + '/k8s/apis/batch/v1/jobs', j => this.cluster.jobs = j)          
        }
    };
    
/*
export function getMetricLastPoints<Keys extends string>(metrics: Partial<Record<Keys, MetricData>>): Partial<Record<Keys, number>> {
  return object.fromEntries(
    object.entries(metrics)
      .map(([metricName, metric]) => {
        try {
          return [metricName, +metric.data.result[0].values.slice(-1)[0][1]] as const;
        } catch {
          return undefined;
        }
      })
      .filter(isDefined),
  );
}    
*/
    
    routes.push({path:'/', name:'cluster',  component: components["cluster"]})
</script>
